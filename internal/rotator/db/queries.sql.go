// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const beginRotation = `-- name: BeginRotation :exec

UPDATE nodes
SET
    status = 'destroying',
    destroy_at = datetime(CURRENT_TIMESTAMP, '+' || ? || ' hours'),
    version = version + 1
WHERE id = ? AND status = 'active' AND version = ?
`

type BeginRotationParams struct {
	Column1 sql.NullString `json:"column_1"`
	ID      string         `json:"id"`
	Version int64          `json:"version"`
}

// ----------------------------------------------------------------------------
// Atomic Operations (Use with transactions)
// ----------------------------------------------------------------------------
// Mark old node for destruction during rotation
// USE IN TRANSACTION with CreateNode
func (q *Queries) BeginRotation(ctx context.Context, arg BeginRotationParams) error {
	_, err := q.db.ExecContext(ctx, beginRotation, arg.Column1, arg.ID, arg.Version)
	return err
}

const cancelNodeDestruction = `-- name: CancelNodeDestruction :exec
UPDATE nodes
SET
    status = 'active',
    destroy_at = NULL,
    version = version + 1
WHERE id = ? AND version = ?
`

type CancelNodeDestructionParams struct {
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Cancel scheduled destruction (FR-13)
func (q *Queries) CancelNodeDestruction(ctx context.Context, arg CancelNodeDestructionParams) error {
	_, err := q.db.ExecContext(ctx, cancelNodeDestruction, arg.ID, arg.Version)
	return err
}

const checkIPConflict = `-- name: CheckIPConflict :one
SELECT EXISTS(SELECT 1 FROM peers WHERE allocated_ip = ?) as ip_exists
`

// Check if an IP address is already allocated
func (q *Queries) CheckIPConflict(ctx context.Context, allocatedIp string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkIPConflict, allocatedIp)
	var ip_exists int64
	err := row.Scan(&ip_exists)
	return ip_exists, err
}

const checkPublicKeyConflict = `-- name: CheckPublicKeyConflict :one
SELECT EXISTS(SELECT 1 FROM peers WHERE public_key = ?) as key_exists
`

// Check if a public key is already in use
func (q *Queries) CheckPublicKeyConflict(ctx context.Context, publicKey string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkPublicKeyConflict, publicKey)
	var key_exists int64
	err := row.Scan(&key_exists)
	return key_exists, err
}

const cleanupAllNodes = `-- name: CleanupAllNodes :exec

DELETE FROM nodes
`

// ============================================================================
// MIGRATION HELPERS
// ============================================================================
// DANGEROUS: Delete all nodes (for testing/reset only)
func (q *Queries) CleanupAllNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupAllNodes)
	return err
}

const countActivePeersByNode = `-- name: CountActivePeersByNode :one
SELECT COUNT(*) as count FROM peers WHERE node_id = ? AND status = 'active'
`

// Count active peers for a specific node
func (q *Queries) CountActivePeersByNode(ctx context.Context, nodeID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivePeersByNode, nodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPeersByNode = `-- name: CountPeersByNode :one
SELECT COUNT(*) as count FROM peers WHERE node_id = ?
`

// Count peers for a specific node
func (q *Queries) CountPeersByNode(ctx context.Context, nodeID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPeersByNode, nodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNode = `-- name: CreateNode :one

INSERT INTO nodes (
    id,
    ip_address,
    server_public_key,
    port,
    status,
    created_at
)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    RETURNING id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients
`

type CreateNodeParams struct {
	ID              string `json:"id"`
	IpAddress       string `json:"ip_address"`
	ServerPublicKey string `json:"server_public_key"`
	Port            int64  `json:"port"`
	Status          string `json:"status"`
}

// ----------------------------------------------------------------------------
// Node Creation & Updates
// ----------------------------------------------------------------------------
// Create a new node (FR-3, FR-9)
func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, createNode,
		arg.ID,
		arg.IpAddress,
		arg.ServerPublicKey,
		arg.Port,
		arg.Status,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const createNodeSubnet = `-- name: CreateNodeSubnet :one
INSERT INTO node_subnets (
    node_id,
    subnet_cidr,
    gateway_ip,
    ip_range_start,
    ip_range_end,
    created_at
)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING node_id, subnet_cidr, gateway_ip, ip_range_start, ip_range_end, created_at
`

type CreateNodeSubnetParams struct {
	NodeID       string `json:"node_id"`
	SubnetCidr   string `json:"subnet_cidr"`
	GatewayIp    string `json:"gateway_ip"`
	IpRangeStart string `json:"ip_range_start"`
	IpRangeEnd   string `json:"ip_range_end"`
}

// Create a new node subnet allocation
func (q *Queries) CreateNodeSubnet(ctx context.Context, arg CreateNodeSubnetParams) (NodeSubnet, error) {
	row := q.db.QueryRowContext(ctx, createNodeSubnet,
		arg.NodeID,
		arg.SubnetCidr,
		arg.GatewayIp,
		arg.IpRangeStart,
		arg.IpRangeEnd,
	)
	var i NodeSubnet
	err := row.Scan(
		&i.NodeID,
		&i.SubnetCidr,
		&i.GatewayIp,
		&i.IpRangeStart,
		&i.IpRangeEnd,
		&i.CreatedAt,
	)
	return i, err
}

const createPeer = `-- name: CreatePeer :one

INSERT INTO peers (
    id,
    node_id,
    public_key,
    allocated_ip,
    preshared_key,
    status,
    created_at
)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
RETURNING id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at
`

type CreatePeerParams struct {
	ID           string         `json:"id"`
	NodeID       string         `json:"node_id"`
	PublicKey    string         `json:"public_key"`
	AllocatedIp  string         `json:"allocated_ip"`
	PresharedKey sql.NullString `json:"preshared_key"`
	Status       string         `json:"status"`
}

// ----------------------------------------------------------------------------
// Peer Creation & Updates
// ----------------------------------------------------------------------------
// Create a new peer
func (q *Queries) CreatePeer(ctx context.Context, arg CreatePeerParams) (Peer, error) {
	row := q.db.QueryRowContext(ctx, createPeer,
		arg.ID,
		arg.NodeID,
		arg.PublicKey,
		arg.AllocatedIp,
		arg.PresharedKey,
		arg.Status,
	)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.PublicKey,
		&i.AllocatedIp,
		&i.PresharedKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastHandshakeAt,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes WHERE id = ?
`

// Permanently delete a node (FR-8, FR-25)
func (q *Queries) DeleteNode(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNode, id)
	return err
}

const deleteNodeSubnet = `-- name: DeleteNodeSubnet :exec
DELETE FROM node_subnets WHERE node_id = ?
`

// Delete a node subnet
func (q *Queries) DeleteNodeSubnet(ctx context.Context, nodeID string) error {
	_, err := q.db.ExecContext(ctx, deleteNodeSubnet, nodeID)
	return err
}

const deletePeer = `-- name: DeletePeer :exec
DELETE FROM peers WHERE id = ?
`

// Delete a peer
func (q *Queries) DeletePeer(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePeer, id)
	return err
}

const deletePeersByNode = `-- name: DeletePeersByNode :exec
DELETE FROM peers WHERE node_id = ?
`

// Delete all peers for a specific node
func (q *Queries) DeletePeersByNode(ctx context.Context, nodeID string) error {
	_, err := q.db.ExecContext(ctx, deletePeersByNode, nodeID)
	return err
}

const getActiveNode = `-- name: GetActiveNode :one
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'active'
ORDER BY created_at DESC
    LIMIT 1
`

// Get the currently active node (FR-17)
// Returns the most recently created active node to handle transition edge cases
func (q *Queries) GetActiveNode(ctx context.Context) (Node, error) {
	row := q.db.QueryRowContext(ctx, getActiveNode)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getAllNodeSubnets = `-- name: GetAllNodeSubnets :many
SELECT node_id, subnet_cidr, gateway_ip, ip_range_start, ip_range_end, created_at FROM node_subnets ORDER BY created_at DESC
`

// Get all node subnets
func (q *Queries) GetAllNodeSubnets(ctx context.Context) ([]NodeSubnet, error) {
	rows, err := q.db.QueryContext(ctx, getAllNodeSubnets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeSubnet{}
	for rows.Next() {
		var i NodeSubnet
		if err := rows.Scan(
			&i.NodeID,
			&i.SubnetCidr,
			&i.GatewayIp,
			&i.IpRangeStart,
			&i.IpRangeEnd,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNodes = `-- name: GetAllNodes :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
ORDER BY created_at DESC
`

// Get all nodes (for debugging/admin)
func (q *Queries) GetAllNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPeers = `-- name: GetAllPeers :many
SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers 
ORDER BY created_at DESC
`

// Get all peers
func (q *Queries) GetAllPeers(ctx context.Context) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getAllPeers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.PublicKey,
			&i.AllocatedIp,
			&i.PresharedKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastHandshakeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllocatedIPsByNode = `-- name: GetAllocatedIPsByNode :many
SELECT allocated_ip FROM peers WHERE node_id = ? ORDER BY allocated_ip
`

// Get all allocated IPs for a specific node
func (q *Queries) GetAllocatedIPsByNode(ctx context.Context, nodeID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllocatedIPsByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var allocated_ip string
		if err := rows.Scan(&allocated_ip); err != nil {
			return nil, err
		}
		items = append(items, allocated_ip)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseVersion = `-- name: GetDatabaseVersion :one
SELECT sqlite_version() as version
`

// Get schema version for migrations
func (q *Queries) GetDatabaseVersion(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getDatabaseVersion)
	var version string
	err := row.Scan(&version)
	return version, err
}

const getIdleNodes = `-- name: GetIdleNodes :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status IN ('active', 'destroying')
  AND (
    connected_clients = 0
        OR last_handshake_at IS NULL
        OR datetime(last_handshake_at, '+' || ? || ' minutes') <= CURRENT_TIMESTAMP
    )
`

// Get nodes with no activity for idle timeout period (FR-12)
// Considers a node idle if:
// 1. No clients connected, OR
// 2. Last handshake was more than idle_minutes ago
func (q *Queries) GetIdleNodes(ctx context.Context, dollar_1 sql.NullString) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getIdleNodes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInactivePeers = `-- name: GetInactivePeers :many
SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers
WHERE status = 'active'
  AND (
    last_handshake_at IS NULL
    OR datetime(last_handshake_at, '+' || ? || ' minutes') <= CURRENT_TIMESTAMP
  )
ORDER BY last_handshake_at ASC
`

// Get peers that have been inactive for a specified duration
func (q *Queries) GetInactivePeers(ctx context.Context, dollar_1 sql.NullString) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getInactivePeers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.PublicKey,
			&i.AllocatedIp,
			&i.PresharedKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastHandshakeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNode = `-- name: GetLatestNode :one
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
ORDER BY created_at DESC
    LIMIT 1
`

// Get the most recently created node regardless of status
func (q *Queries) GetLatestNode(ctx context.Context) (Node, error) {
	row := q.db.QueryRowContext(ctx, getLatestNode)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNode = `-- name: GetNode :one

SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes WHERE id = ? LIMIT 1
`

// ----------------------------------------------------------------------------
// Node Retrieval
// ----------------------------------------------------------------------------
// Get a specific node by ID
func (q *Queries) GetNode(ctx context.Context, id string) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNode, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNodeByIP = `-- name: GetNodeByIP :one
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes WHERE ip_address = ? LIMIT 1
`

// Get a specific node by IP address
func (q *Queries) GetNodeByIP(ctx context.Context, ipAddress string) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNodeByIP, ipAddress)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNodeCount = `-- name: GetNodeCount :one

SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'provisioning' THEN 1 ELSE 0 END) as provisioning,
    SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
    SUM(CASE WHEN status = 'destroying' THEN 1 ELSE 0 END) as destroying
FROM nodes
`

type GetNodeCountRow struct {
	Total        int64           `json:"total"`
	Provisioning sql.NullFloat64 `json:"provisioning"`
	Active       sql.NullFloat64 `json:"active"`
	Destroying   sql.NullFloat64 `json:"destroying"`
}

// ----------------------------------------------------------------------------
// Health & Statistics
// ----------------------------------------------------------------------------
// Count nodes by status
func (q *Queries) GetNodeCount(ctx context.Context) (GetNodeCountRow, error) {
	row := q.db.QueryRowContext(ctx, getNodeCount)
	var i GetNodeCountRow
	err := row.Scan(
		&i.Total,
		&i.Provisioning,
		&i.Active,
		&i.Destroying,
	)
	return i, err
}

const getNodeForUpdate = `-- name: GetNodeForUpdate :one
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes WHERE id = ? LIMIT 1
`

// Get node with lock for update (use in transaction)
// SQLite doesn't have SELECT FOR UPDATE, but this documents intent
func (q *Queries) GetNodeForUpdate(ctx context.Context, id string) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNodeForUpdate, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ServerID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNodeSubnet = `-- name: GetNodeSubnet :one

SELECT node_id, subnet_cidr, gateway_ip, ip_range_start, ip_range_end, created_at FROM node_subnets WHERE node_id = ? LIMIT 1
`

// ----------------------------------------------------------------------------
// Node Subnet Queries
// ----------------------------------------------------------------------------
// Get subnet information for a specific node
func (q *Queries) GetNodeSubnet(ctx context.Context, nodeID string) (NodeSubnet, error) {
	row := q.db.QueryRowContext(ctx, getNodeSubnet, nodeID)
	var i NodeSubnet
	err := row.Scan(
		&i.NodeID,
		&i.SubnetCidr,
		&i.GatewayIp,
		&i.IpRangeStart,
		&i.IpRangeEnd,
		&i.CreatedAt,
	)
	return i, err
}

const getNodeSubnetBySubnetCIDR = `-- name: GetNodeSubnetBySubnetCIDR :one
SELECT node_id, subnet_cidr, gateway_ip, ip_range_start, ip_range_end, created_at FROM node_subnets WHERE subnet_cidr = ? LIMIT 1
`

// Get node subnet by CIDR
func (q *Queries) GetNodeSubnetBySubnetCIDR(ctx context.Context, subnetCidr string) (NodeSubnet, error) {
	row := q.db.QueryRowContext(ctx, getNodeSubnetBySubnetCIDR, subnetCidr)
	var i NodeSubnet
	err := row.Scan(
		&i.NodeID,
		&i.SubnetCidr,
		&i.GatewayIp,
		&i.IpRangeStart,
		&i.IpRangeEnd,
		&i.CreatedAt,
	)
	return i, err
}

const getNodesByStatus = `-- name: GetNodesByStatus :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = ?
ORDER BY created_at DESC
`

// Get all nodes with a specific status
func (q *Queries) GetNodesByStatus(ctx context.Context, status string) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesDueForRotation = `-- name: GetNodesDueForRotation :many

SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'active'
  AND datetime(created_at, '+' || ? || ' hours') <= CURRENT_TIMESTAMP
  AND connected_clients > 0
`

// ----------------------------------------------------------------------------
// Rotation & Cleanup Queries
// ----------------------------------------------------------------------------
// Get nodes that need rotation (FR-2)
// Active nodes older than rotation interval
func (q *Queries) GetNodesDueForRotation(ctx context.Context, dollar_1 sql.NullString) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesDueForRotation, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesForDestruction = `-- name: GetNodesForDestruction :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'destroying'
  AND destroy_at IS NOT NULL
  AND destroy_at <= CURRENT_TIMESTAMP
`

// Get nodes whose grace period has expired (FR-8)
func (q *Queries) GetNodesForDestruction(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesForDestruction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesScheduledForDestruction = `-- name: GetNodesScheduledForDestruction :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE destroy_at IS NOT NULL
ORDER BY destroy_at ASC
`

// Get all nodes with scheduled destruction (for monitoring)
func (q *Queries) GetNodesScheduledForDestruction(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesScheduledForDestruction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedNodes = `-- name: GetOrphanedNodes :many
SELECT id, server_id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE (
          (status = 'provisioning' AND datetime(created_at, '+1 hour') <= CURRENT_TIMESTAMP)
              OR (status = 'destroying' AND destroy_at IS NOT NULL AND datetime(destroy_at, '+1 hour') <= CURRENT_TIMESTAMP)
          )
`

// Get nodes stuck in non-terminal states (FR-25)
// Provisioning for >1 hour or destroying for >1 hour
func (q *Queries) GetOrphanedNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ServerID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeer = `-- name: GetPeer :one


SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers WHERE id = ? LIMIT 1
`

// ============================================================================
// PEER MANAGEMENT QUERIES
// ============================================================================
// ----------------------------------------------------------------------------
// Peer Retrieval
// ----------------------------------------------------------------------------
// Get a specific peer by ID
func (q *Queries) GetPeer(ctx context.Context, id string) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeer, id)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.PublicKey,
		&i.AllocatedIp,
		&i.PresharedKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastHandshakeAt,
	)
	return i, err
}

const getPeerByPublicKey = `-- name: GetPeerByPublicKey :one
SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers WHERE public_key = ? LIMIT 1
`

// Get a peer by public key
func (q *Queries) GetPeerByPublicKey(ctx context.Context, publicKey string) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeerByPublicKey, publicKey)
	var i Peer
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.PublicKey,
		&i.AllocatedIp,
		&i.PresharedKey,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastHandshakeAt,
	)
	return i, err
}

const getPeerStatistics = `-- name: GetPeerStatistics :one
SELECT
    COUNT(*) as total_peers,
    SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_peers,
    SUM(CASE WHEN status = 'disconnected' THEN 1 ELSE 0 END) as disconnected_peers,
    SUM(CASE WHEN status = 'removing' THEN 1 ELSE 0 END) as removing_peers
FROM peers
`

type GetPeerStatisticsRow struct {
	TotalPeers        int64           `json:"total_peers"`
	ActivePeers       sql.NullFloat64 `json:"active_peers"`
	DisconnectedPeers sql.NullFloat64 `json:"disconnected_peers"`
	RemovingPeers     sql.NullFloat64 `json:"removing_peers"`
}

// Get peer statistics across all nodes
func (q *Queries) GetPeerStatistics(ctx context.Context) (GetPeerStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getPeerStatistics)
	var i GetPeerStatisticsRow
	err := row.Scan(
		&i.TotalPeers,
		&i.ActivePeers,
		&i.DisconnectedPeers,
		&i.RemovingPeers,
	)
	return i, err
}

const getPeersByNode = `-- name: GetPeersByNode :many
SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers 
WHERE node_id = ? 
ORDER BY created_at DESC
`

// Get all peers for a specific node
func (q *Queries) GetPeersByNode(ctx context.Context, nodeID string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getPeersByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.PublicKey,
			&i.AllocatedIp,
			&i.PresharedKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastHandshakeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeersByStatus = `-- name: GetPeersByStatus :many
SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers 
WHERE status = ? 
ORDER BY created_at DESC
`

// Get all peers with a specific status
func (q *Queries) GetPeersByStatus(ctx context.Context, status string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getPeersByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.PublicKey,
			&i.AllocatedIp,
			&i.PresharedKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastHandshakeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeersForMigration = `-- name: GetPeersForMigration :many

SELECT id, node_id, public_key, allocated_ip, preshared_key, status, created_at, updated_at, last_handshake_at FROM peers 
WHERE node_id = ? AND status = 'active'
ORDER BY created_at ASC
`

// ----------------------------------------------------------------------------
// Peer Management Operations
// ----------------------------------------------------------------------------
// Get active peers that need to be migrated from a node
func (q *Queries) GetPeersForMigration(ctx context.Context, nodeID string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getPeersForMigration, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.PublicKey,
			&i.AllocatedIp,
			&i.PresharedKey,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastHandshakeAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalConnectedClients = `-- name: GetTotalConnectedClients :one
SELECT COALESCE(SUM(connected_clients), 0) as total_clients
FROM nodes
WHERE status = 'active'
`

// Sum of all connected clients across all nodes
func (q *Queries) GetTotalConnectedClients(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalConnectedClients)
	var total_clients interface{}
	err := row.Scan(&total_clients)
	return total_clients, err
}

const getUsedSubnetCIDRs = `-- name: GetUsedSubnetCIDRs :many
SELECT subnet_cidr FROM node_subnets ORDER BY subnet_cidr
`

// Get all used subnet CIDRs
func (q *Queries) GetUsedSubnetCIDRs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUsedSubnetCIDRs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subnet_cidr string
		if err := rows.Scan(&subnet_cidr); err != nil {
			return nil, err
		}
		items = append(items, subnet_cidr)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasActiveNode = `-- name: HasActiveNode :one
SELECT EXISTS(SELECT 1 FROM nodes WHERE status = 'active') as has_active
`

// Quick check if any active node exists (FR-17, FR-20)
func (q *Queries) HasActiveNode(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasActiveNode)
	var has_active int64
	err := row.Scan(&has_active)
	return has_active, err
}

const markNodeActive = `-- name: MarkNodeActive :exec
UPDATE nodes
SET
    status = 'active',
    version = version + 1
WHERE id = ? AND status = 'provisioning' AND version = ?
`

type MarkNodeActiveParams struct {
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Transition node from provisioning to active (FR-6)
func (q *Queries) MarkNodeActive(ctx context.Context, arg MarkNodeActiveParams) error {
	_, err := q.db.ExecContext(ctx, markNodeActive, arg.ID, arg.Version)
	return err
}

const scheduleNodeDestruction = `-- name: ScheduleNodeDestruction :exec
UPDATE nodes
SET
    status = 'destroying',
    destroy_at = ?,
    version = version + 1
WHERE id = ? AND version = ?
`

type ScheduleNodeDestructionParams struct {
	DestroyAt sql.NullTime `json:"destroy_at"`
	ID        string       `json:"id"`
	Version   int64        `json:"version"`
}

// Mark node for destruction with grace period (FR-7, FR-8)
func (q *Queries) ScheduleNodeDestruction(ctx context.Context, arg ScheduleNodeDestructionParams) error {
	_, err := q.db.ExecContext(ctx, scheduleNodeDestruction, arg.DestroyAt, arg.ID, arg.Version)
	return err
}

const updateNodeActivity = `-- name: UpdateNodeActivity :exec
UPDATE nodes
SET
    last_handshake_at = ?,
    connected_clients = ?
WHERE id = ?
`

type UpdateNodeActivityParams struct {
	LastHandshakeAt  sql.NullTime `json:"last_handshake_at"`
	ConnectedClients int64        `json:"connected_clients"`
	ID               string       `json:"id"`
}

// Update last handshake time and client count (FR-10, FR-11)
func (q *Queries) UpdateNodeActivity(ctx context.Context, arg UpdateNodeActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateNodeActivity, arg.LastHandshakeAt, arg.ConnectedClients, arg.ID)
	return err
}

const updateNodeDetails = `-- name: UpdateNodeDetails :exec
UPDATE nodes
SET
    server_id = ?,
    ip_address = ?,
    server_public_key = ?,
    version = version + 1
WHERE id = ? AND status = 'provisioning' AND version = ?
`

type UpdateNodeDetailsParams struct {
	ServerID        sql.NullString `json:"server_id"`
	IpAddress       string         `json:"ip_address"`
	ServerPublicKey string         `json:"server_public_key"`
	ID              string         `json:"id"`
	Version         int64          `json:"version"`
}

// Update node IP address and public key while keeping provisioning status
func (q *Queries) UpdateNodeDetails(ctx context.Context, arg UpdateNodeDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateNodeDetails,
		arg.ServerID,
		arg.IpAddress,
		arg.ServerPublicKey,
		arg.ID,
		arg.Version,
	)
	return err
}

const updateNodeStatus = `-- name: UpdateNodeStatus :exec
UPDATE nodes
SET
    status = ?,
    version = version + 1
WHERE id = ? AND version = ?
`

type UpdateNodeStatusParams struct {
	Status  string `json:"status"`
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Update node status with optimistic locking (FR-16)
// Returns error if version doesn't match (concurrent modification)
func (q *Queries) UpdateNodeStatus(ctx context.Context, arg UpdateNodeStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNodeStatus, arg.Status, arg.ID, arg.Version)
	return err
}

const updatePeerLastHandshake = `-- name: UpdatePeerLastHandshake :exec
UPDATE peers
SET last_handshake_at = ?
WHERE id = ?
`

type UpdatePeerLastHandshakeParams struct {
	LastHandshakeAt sql.NullTime `json:"last_handshake_at"`
	ID              string       `json:"id"`
}

// Update peer last handshake time
func (q *Queries) UpdatePeerLastHandshake(ctx context.Context, arg UpdatePeerLastHandshakeParams) error {
	_, err := q.db.ExecContext(ctx, updatePeerLastHandshake, arg.LastHandshakeAt, arg.ID)
	return err
}

const updatePeerNode = `-- name: UpdatePeerNode :exec
UPDATE peers
SET node_id = ?, allocated_ip = ?
WHERE id = ?
`

type UpdatePeerNodeParams struct {
	NodeID      string `json:"node_id"`
	AllocatedIp string `json:"allocated_ip"`
	ID          string `json:"id"`
}

// Move a peer to a different node (for migration)
func (q *Queries) UpdatePeerNode(ctx context.Context, arg UpdatePeerNodeParams) error {
	_, err := q.db.ExecContext(ctx, updatePeerNode, arg.NodeID, arg.AllocatedIp, arg.ID)
	return err
}

const updatePeerStatus = `-- name: UpdatePeerStatus :exec
UPDATE peers
SET status = ?
WHERE id = ?
`

type UpdatePeerStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

// Update peer status
func (q *Queries) UpdatePeerStatus(ctx context.Context, arg UpdatePeerStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePeerStatus, arg.Status, arg.ID)
	return err
}
