// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const beginRotation = `-- name: BeginRotation :exec

UPDATE nodes
SET
    status = 'destroying',
    destroy_at = datetime(CURRENT_TIMESTAMP, '+' || ? || ' hours'),
    version = version + 1
WHERE id = ? AND status = 'active' AND version = ?
`

type BeginRotationParams struct {
	Column1 sql.NullString `json:"column_1"`
	ID      string         `json:"id"`
	Version int64          `json:"version"`
}

// ----------------------------------------------------------------------------
// Atomic Operations (Use with transactions)
// ----------------------------------------------------------------------------
// Mark old node for destruction during rotation
// USE IN TRANSACTION with CreateNode
func (q *Queries) BeginRotation(ctx context.Context, arg BeginRotationParams) error {
	_, err := q.db.ExecContext(ctx, beginRotation, arg.Column1, arg.ID, arg.Version)
	return err
}

const cancelNodeDestruction = `-- name: CancelNodeDestruction :exec
UPDATE nodes
SET
    status = 'active',
    destroy_at = NULL,
    version = version + 1
WHERE id = ? AND version = ?
`

type CancelNodeDestructionParams struct {
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Cancel scheduled destruction (FR-13)
func (q *Queries) CancelNodeDestruction(ctx context.Context, arg CancelNodeDestructionParams) error {
	_, err := q.db.ExecContext(ctx, cancelNodeDestruction, arg.ID, arg.Version)
	return err
}

const cleanupAllNodes = `-- name: CleanupAllNodes :exec

DELETE FROM nodes
`

// ============================================================================
// MIGRATION HELPERS
// ============================================================================
// DANGEROUS: Delete all nodes (for testing/reset only)
func (q *Queries) CleanupAllNodes(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupAllNodes)
	return err
}

const createNode = `-- name: CreateNode :one

INSERT INTO nodes (
    id,
    ip_address,
    server_public_key,
    port,
    status,
    created_at
)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    RETURNING id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients
`

type CreateNodeParams struct {
	ID              string `json:"id"`
	IpAddress       string `json:"ip_address"`
	ServerPublicKey string `json:"server_public_key"`
	Port            int64  `json:"port"`
	Status          string `json:"status"`
}

// ----------------------------------------------------------------------------
// Node Creation & Updates
// ----------------------------------------------------------------------------
// Create a new node (FR-3, FR-9)
func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, createNode,
		arg.ID,
		arg.IpAddress,
		arg.ServerPublicKey,
		arg.Port,
		arg.Status,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes WHERE id = ?
`

// Permanently delete a node (FR-8, FR-25)
func (q *Queries) DeleteNode(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNode, id)
	return err
}

const getActiveNode = `-- name: GetActiveNode :one
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'active'
ORDER BY created_at DESC
    LIMIT 1
`

// Get the currently active node (FR-17)
// Returns the most recently created active node to handle transition edge cases
func (q *Queries) GetActiveNode(ctx context.Context) (Node, error) {
	row := q.db.QueryRowContext(ctx, getActiveNode)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getAllNodes = `-- name: GetAllNodes :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
ORDER BY created_at DESC
`

// Get all nodes (for debugging/admin)
func (q *Queries) GetAllNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseVersion = `-- name: GetDatabaseVersion :one
SELECT sqlite_version() as version
`

// Get schema version for migrations
func (q *Queries) GetDatabaseVersion(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getDatabaseVersion)
	var version string
	err := row.Scan(&version)
	return version, err
}

const getIdleNodes = `-- name: GetIdleNodes :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status IN ('active', 'destroying')
  AND (
    connected_clients = 0
        OR last_handshake_at IS NULL
        OR datetime(last_handshake_at, '+' || ? || ' minutes') <= CURRENT_TIMESTAMP
    )
`

// Get nodes with no activity for idle timeout period (FR-12)
// Considers a node idle if:
// 1. No clients connected, OR
// 2. Last handshake was more than idle_minutes ago
func (q *Queries) GetIdleNodes(ctx context.Context, dollar_1 sql.NullString) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getIdleNodes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNode = `-- name: GetLatestNode :one
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
ORDER BY created_at DESC
    LIMIT 1
`

// Get the most recently created node regardless of status
func (q *Queries) GetLatestNode(ctx context.Context) (Node, error) {
	row := q.db.QueryRowContext(ctx, getLatestNode)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNode = `-- name: GetNode :one

SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes WHERE id = ? LIMIT 1
`

// ----------------------------------------------------------------------------
// Node Retrieval
// ----------------------------------------------------------------------------
// Get a specific node by ID
func (q *Queries) GetNode(ctx context.Context, id string) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNode, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNodeCount = `-- name: GetNodeCount :one

SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'provisioning' THEN 1 ELSE 0 END) as provisioning,
    SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active,
    SUM(CASE WHEN status = 'destroying' THEN 1 ELSE 0 END) as destroying
FROM nodes
`

type GetNodeCountRow struct {
	Total        int64           `json:"total"`
	Provisioning sql.NullFloat64 `json:"provisioning"`
	Active       sql.NullFloat64 `json:"active"`
	Destroying   sql.NullFloat64 `json:"destroying"`
}

// ----------------------------------------------------------------------------
// Health & Statistics
// ----------------------------------------------------------------------------
// Count nodes by status
func (q *Queries) GetNodeCount(ctx context.Context) (GetNodeCountRow, error) {
	row := q.db.QueryRowContext(ctx, getNodeCount)
	var i GetNodeCountRow
	err := row.Scan(
		&i.Total,
		&i.Provisioning,
		&i.Active,
		&i.Destroying,
	)
	return i, err
}

const getNodeForUpdate = `-- name: GetNodeForUpdate :one
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes WHERE id = ? LIMIT 1
`

// Get node with lock for update (use in transaction)
// SQLite doesn't have SELECT FOR UPDATE, but this documents intent
func (q *Queries) GetNodeForUpdate(ctx context.Context, id string) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNodeForUpdate, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.IpAddress,
		&i.ServerPublicKey,
		&i.Port,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DestroyAt,
		&i.LastHandshakeAt,
		&i.ConnectedClients,
	)
	return i, err
}

const getNodesByStatus = `-- name: GetNodesByStatus :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = ?
ORDER BY created_at DESC
`

// Get all nodes with a specific status
func (q *Queries) GetNodesByStatus(ctx context.Context, status string) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesDueForRotation = `-- name: GetNodesDueForRotation :many

SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'active'
  AND datetime(created_at, '+' || ? || ' hours') <= CURRENT_TIMESTAMP
  AND connected_clients > 0
`

// ----------------------------------------------------------------------------
// Rotation & Cleanup Queries
// ----------------------------------------------------------------------------
// Get nodes that need rotation (FR-2)
// Active nodes older than rotation interval
func (q *Queries) GetNodesDueForRotation(ctx context.Context, dollar_1 sql.NullString) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesDueForRotation, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesForDestruction = `-- name: GetNodesForDestruction :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE status = 'destroying'
  AND destroy_at IS NOT NULL
  AND destroy_at <= CURRENT_TIMESTAMP
`

// Get nodes whose grace period has expired (FR-8)
func (q *Queries) GetNodesForDestruction(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesForDestruction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesScheduledForDestruction = `-- name: GetNodesScheduledForDestruction :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE destroy_at IS NOT NULL
ORDER BY destroy_at ASC
`

// Get all nodes with scheduled destruction (for monitoring)
func (q *Queries) GetNodesScheduledForDestruction(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesScheduledForDestruction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedNodes = `-- name: GetOrphanedNodes :many
SELECT id, ip_address, server_public_key, port, status, version, created_at, updated_at, destroy_at, last_handshake_at, connected_clients FROM nodes
WHERE (
          (status = 'provisioning' AND datetime(created_at, '+1 hour') <= CURRENT_TIMESTAMP)
              OR (status = 'destroying' AND destroy_at IS NOT NULL AND datetime(destroy_at, '+1 hour') <= CURRENT_TIMESTAMP)
          )
`

// Get nodes stuck in non-terminal states (FR-25)
// Provisioning for >1 hour or destroying for >1 hour
func (q *Queries) GetOrphanedNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.ServerPublicKey,
			&i.Port,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DestroyAt,
			&i.LastHandshakeAt,
			&i.ConnectedClients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalConnectedClients = `-- name: GetTotalConnectedClients :one
SELECT COALESCE(SUM(connected_clients), 0) as total_clients
FROM nodes
WHERE status = 'active'
`

// Sum of all connected clients across all nodes
func (q *Queries) GetTotalConnectedClients(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalConnectedClients)
	var total_clients interface{}
	err := row.Scan(&total_clients)
	return total_clients, err
}

const hasActiveNode = `-- name: HasActiveNode :one
SELECT EXISTS(SELECT 1 FROM nodes WHERE status = 'active') as has_active
`

// Quick check if any active node exists (FR-17, FR-20)
func (q *Queries) HasActiveNode(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasActiveNode)
	var has_active int64
	err := row.Scan(&has_active)
	return has_active, err
}

const markNodeActive = `-- name: MarkNodeActive :exec
UPDATE nodes
SET
    status = 'active',
    version = version + 1
WHERE id = ? AND status = 'provisioning' AND version = ?
`

type MarkNodeActiveParams struct {
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Transition node from provisioning to active (FR-6)
func (q *Queries) MarkNodeActive(ctx context.Context, arg MarkNodeActiveParams) error {
	_, err := q.db.ExecContext(ctx, markNodeActive, arg.ID, arg.Version)
	return err
}

const scheduleNodeDestruction = `-- name: ScheduleNodeDestruction :exec
UPDATE nodes
SET
    status = 'destroying',
    destroy_at = ?,
    version = version + 1
WHERE id = ? AND version = ?
`

type ScheduleNodeDestructionParams struct {
	DestroyAt sql.NullTime `json:"destroy_at"`
	ID        string       `json:"id"`
	Version   int64        `json:"version"`
}

// Mark node for destruction with grace period (FR-7, FR-8)
func (q *Queries) ScheduleNodeDestruction(ctx context.Context, arg ScheduleNodeDestructionParams) error {
	_, err := q.db.ExecContext(ctx, scheduleNodeDestruction, arg.DestroyAt, arg.ID, arg.Version)
	return err
}

const updateNodeActivity = `-- name: UpdateNodeActivity :exec
UPDATE nodes
SET
    last_handshake_at = ?,
    connected_clients = ?
WHERE id = ?
`

type UpdateNodeActivityParams struct {
	LastHandshakeAt  sql.NullTime `json:"last_handshake_at"`
	ConnectedClients int64        `json:"connected_clients"`
	ID               string       `json:"id"`
}

// Update last handshake time and client count (FR-10, FR-11)
func (q *Queries) UpdateNodeActivity(ctx context.Context, arg UpdateNodeActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateNodeActivity, arg.LastHandshakeAt, arg.ConnectedClients, arg.ID)
	return err
}

const updateNodeStatus = `-- name: UpdateNodeStatus :exec
UPDATE nodes
SET
    status = ?,
    version = version + 1
WHERE id = ? AND version = ?
`

type UpdateNodeStatusParams struct {
	Status  string `json:"status"`
	ID      string `json:"id"`
	Version int64  `json:"version"`
}

// Update node status with optimistic locking (FR-16)
// Returns error if version doesn't match (concurrent modification)
func (q *Queries) UpdateNodeStatus(ctx context.Context, arg UpdateNodeStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateNodeStatus, arg.Status, arg.ID, arg.Version)
	return err
}
